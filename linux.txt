<command1> && <command2> >-> runs command2 only if command1 is successful

groups >-> see to which groups the logged user belongs

sudo adduser <username> <groupName> >-> add user <username> to group <groupName>

sudo !! >-> run previous command with sudo prepended

docker build -t <name>:<optioanlTag> >-> name and optional tag an image

docker build -t <name:tag> -f <someDir>/Dockerfile <someOtherDir> >->
        - -f >-> use Dockerfile from a different path
        - uses someOtherDir as the build context

Dockerfile
        - FROM >-> define the base image
        - RUN >-> runs the defined command inside the container
        - CMD >-> should be used to run the software contained by the image
        - EXPOSE >-> indicates the ports on which a container listens for connections
        - ENV <key>=<value> >-> create an environment varabiable wirh name key and value <value>
        - COPY >-> supports only basic copying of local files into the container
        - ADD >-> similiar to COPY additionaly has local-only tar extraction

echo -e <content> >-> enable character escaping like '\n'
echo <content> >> <file> >-> appends content to file

stat <pathToFile> >-> get details about file/dir - also get permissions like `-rw-r--r--` as an integer as, e.g. 644
chmod <permission> -R <path> >-> recursively set permission to dir path and all subdirs and files 

apt-get install -y <packageName> >-> installs packageName without the additional confirmation prompt

scp <pathToFile/Dir> <destinationIp/HostName>:<destinationPath> >-> copies file/dir from host to destinationIp/Host

mkdir -p <directory> >->
	- no errors if directories already exist 
	- creates directory including parent directories

mv <fileName> <dirName> >-> moves <fileName> to the <dirName>

grep '<text>' <sourceFilePath> > <targetFilePath> >-> filter lines from SourceFile and add them to the targetFile

git

git branch <newLocalBranchName> origin/<existingRemoteBranch> >-> checkout remote branch
git push -u origin <branchName> >-> avoid additional prompt when pushing new branch to remote

mvn

mvn dependency:tree >-> output
<some-dependency>:2.5:provided (version managed from 2.3; scope managed from compile)
	- the version some-dependency would have transitively been 2.3 
	- but that version 2.5 was specifically asked for in your project, so that is what was used.

<dependency> without <version>
its possible to define a <dependencyManagement> configfuration in the parent pom to define versions of dependencies
	- this has the result that we can omitt the <version> part of the dependency if it is defines using
		dependencyManagement

mvn help:dependency-tree >-> generates a tree-like representation of direct/transitive dependencies

sbt
	dockerBaseImage       := "openjdk:jre-alpine"
	add enablePlugins(DockerPlugin) to build.sbt
	sbt docker:publishLocal

docker
Docker’s main purpose is to give us run-time environments that we can re-create/reproduce on any machine (that runs Docker)

A Docker image is not a runtime, it’s rather a collection of files, libraries and configuration files that build up an environment.

while bind mounts are dependent on the directory structure of the host machine, volumes are completely managed by docker.

docker run -d -e KEYCLOAK_USER=admin -e KEYCLOAK_PASSWORD=admin -p 8080:8080 jboss/keycloak >-> running keycloak in a docker container

docker ps -a -q >-> lists only ids of all containers
docker image list -q >-> lists only ids of all images

docker rm $(docker ps -a -q) >-> remove all containers
docker rmi $(docker image list -q) >-> remove all imamges

docker build -t <name>:<optioanlTag> >-> name and optional tag an image

docker build -t <name:tag> -f <someDir>/Dockerfile <someOtherDir> >->
	- -f >-> use Dockerfile from a different path
	- uses someOtherDir as the build context

Dockerfile
	- FROM >-> define the base image
	- RUN >-> runs the defined command inside the container, executes the command in a new layer and creates a new image
	- CMD >-> should be used to run the software contained by the image
	- EXPOSE >-> indicates the ports on which a container listens for connections
	- ENV <key>=<value> >-> create an environment varabiable wirh name key and value <value>
	- COPY >-> supports only basic copying of local files into the container
	- ADD >-> similiar to COPY additionaly has local-only tar extraction
	- ENTRYPOINT >-> is set to the images main command
	- ARG[=<defaultValue>] >-> an argument which can be passed buring the building process, optional default value
		- ENTRYPOINT ["s3cmd"]
		- CMD ["--help"]
		- docker run s3cmd 
	- VOLUME >-> should be used to expose any database storage area, configuration storage, or files/folders created by the docker container
			- for any mutable and/or user serviceable parts of your image

docker-compose
	-f <pathToDockerCompose> >-> path to the file which should be used by docker-compose
	-p specify project name

	docker-compose up >-> starts all containers defined by the docker-compose.yml file
		-d >-> in detached mode
	docker-compose images >-> lists all images container in the docker-compose file
	docker-compose top >-> lists all running processes started by docker-compose
	docker-compose stop >-> gracefully stops containers
	docker-compose kill >-> kills all containers
	docker-compose ps >-> list all containers
